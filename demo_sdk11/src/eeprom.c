/******************************************************************************
(С) ООО "ЛМТ", Санкт-Петербург, Россия, 2002.
http://lmt.cs.ifmo.ru, tel.: +7-812-233-3096,
mailto: lmt@d1.ifmo.ru

Данный файл является свободно распространяемым примером работы
с микросхемой EEPROM учебного стенда SDK-1.1 на языке Си
(компилятор Keil C фирмы KEIL ELEKTRONIK GmbH) и предназначен для
иллюстрации работы с устройством.
Данный программный модуль не подвергался тщательному
тестированию и может содержать ошибки. Авторы не несут 
ответственности за потерю информации и иные возможные вредные
последствия использования данного программного модуля в составе
программных проектов.
Данный файл может подвергаться любым изменениям, но не может
распространяться в коммерческих целях и в составе коммерческих
программных продуктов.


Файл: eeprom.c
Версия: 1.0.0
Автор: LAN
Описание: Набор демонстрационного программного обеспечения для стенда
SDK-1.1. Работа с EEPROM. Данный модуль использует модуль
работы с интерфейсом I2C (i2c.h, i2c.c).

Изменения:
-------------------------------------------------------------------------------
N Дата Версия Автор Описание 
-------------------------------------------------------------------------------
1 10.04.02 1.0.0 LAN Создан
******************************************************************************/

#include "eeprom.h" //Описание I2C-адреса EEPROM
#include "i2c.h" //Функции модуля работы с I2C.

/*----------------------------------------------------------------------------
Функции
-----------------------------------------------------------------------------*/

/**----------------------------------------------------------------------------
WriteBlockEEPROM()
-------------------------------------------------------------------------------
Зпись блока данных в EEPROM. Контроль тайм-аута на ответ EEPROM примитивный,
выполнен за счет отслеживания примерной длительности исполнения цикла ожидания
ответа. Записываемый блок, если он больше 8 байт, разбивается на "страницы"
по 8 байт, которые последовательно передаются EEPROM для записи.

Вход: uchar address - адрес (номер ячейки) EEPROM, с которого нужно
поместить блок;
uchar *buf - указатель на блок в области xdata;
uchar length - длина блока. length + address не должно превышать 
размера EEPROM (определяется константой EEPROM_SIZE (eeprom.h)).
Выход: нет
Результат: 0 - успешно;
1 - EEPROM не отвечает, либо длина блока больше EEPROM_SIZE
----------------------------------------------------------------------------- */
bit WriteBlockEEPROM(unsigned char address, unsigned char xdata *buf, unsigned char length)
{
unsigned short try;
unsigned char pages, i, remainder;

if((address + length) > EEPROM_SIZE) 
{
return 1;
}

pages = length / 8;
remainder = length % 8;

for(i = 0; i < pages; ++i)
{
try = 0;
while(!GetAck(EEPROM_ADDRESS))
{
if(++try > 5000)
{
return 1; //EEPROM failed to respond
}
}

if( TransmitBlock(EEPROM_ADDRESS, address + (i<<3), buf + (i<<3), 8) )
{
return 1; //Error writing
}
}

if( remainder )
{
try = 0;
while(!GetAck(EEPROM_ADDRESS))
{
if(++try > 5000)
{
return 1; //EEPROM failed to respond
}
}

if( TransmitBlock(EEPROM_ADDRESS, address + (i<<3), buf + (i<<3), remainder) )
{
return 1; //Error writing
}
}

return 0;
}


/**----------------------------------------------------------------------------
ReadBlockEEPROM()
-------------------------------------------------------------------------------
Чтение блока данных из EEPROM. 

Вход: uchar address - адрес (номер ячейки) EEPROM, с которого нужно
прочесть блок;
uchar *buf - указатель на блок в области xdata;
uchar length - длина блока. length + address не должно превышать 
размера EEPROM (определяется константой EEPROM_SIZE (eeprom.h)).
Выход: нет
Результат: 0 - успешно;
1 - EEPROM не отвечает, либо длина блока больше EEPROM_SIZE
----------------------------------------------------------------------------- */
bit ReadBlockEEPROM(unsigned char address, unsigned char xdata *buf, unsigned char length)
{
unsigned short try;

if((address + length) > EEPROM_SIZE) return 1;

try = 0;
while(!GetAck(EEPROM_ADDRESS))
{
if(++try > 5000) // >10 мс
return 1; //EEPROM failed to respond
}

if( ReceiveBlock(EEPROM_ADDRESS, address, buf, length) )
{
return 1; //Error writing
}

return 0;
}


